### Иллюстрация подхода ожидания завершения некоторых процессов через использование channel и join

#### Предположение

Ожидание через join дает большие задержки, тем больше, чем больше количество отслеживаемых процессов и выше вероятность ошибки. Это связано с тем, что в случае join, в худшем случае придется дождаться завершения всех процессов, в то время, как при использовании channel выход осуществляется немедленно, связано это с архитектурными ограничениями join.

#### Условие задачи

1. Для имитации работы запускается N файберов, каждый из которых засыпает на случайное время, но не более 1 секунды
2. С указанной вероятностью файбер вместо результата возвращает ошибку
3. При получении ошибки от любого из файберов итерация завершается

#### Запуск

```
tarantool ./bench.lua
```

#### Настройка

Смотри файл ```bench.lua```:

```
local workers = 100
local chance_of_error = 98
local iterations = 100
```

#### Прогон тестов на моей машине

```
workers:            10
chance of error, %: 2
iterations:         100
benchmarking of channel..
78.240322113037 seconds
benchmarking of join..
89.086318969727 seconds
```

```
workers:            10
chance of error, %: 50
iterations:         100
benchmarking of channel..
16.547489881516 seconds
benchmarking of join..
58.657691955566 seconds
```

```
workers:            100
chance of error, %: 2
iterations:         100
benchmarking of channel..
38.712564945221 seconds
benchmarking of join..
94.660372018814 seconds
```

```
workers:            100
chance of error, %: 50
iterations:         100
benchmarking of channel..
1.9756760597229 seconds
benchmarking of join..
61.734074115753 seconds```
```

#### Заключение

Опытным путем удалось подтвердить, что реализация на join оказалась очень зависима от процента ошибок и количества ожидаемых процессов и является значительно менее эффективной, чем реализация на channel.
